import { BigNumber, BigNumberish } from 'ethers';
import { Token, TokenOrAddress, TokenTypes } from './token';
export interface TokenAmountObject {
    token: TokenTypes;
    amount: string;
}
export type TokenAmountPair = [TokenTypes, string];
export declare class TokenAmount {
    readonly token: Token;
    amount: string;
    constructor(token: TokenTypes, amount?: string);
    constructor(tokenAmountObject: TokenAmountObject);
    constructor(tokenAmountPair: TokenAmountPair);
    constructor(tokenAmount: TokenAmount);
    static from(tokenAmountObject: TokenAmountObject): TokenAmount;
    static precise(amount: string, decimals: number): string;
    get amountWei(): BigNumber;
    precise(amount: string): string;
    precise(tokenAmount: TokenAmount): string;
    set(amount: string): TokenAmount;
    set(tokenAmount: TokenAmount): TokenAmount;
    setWei(amountWei: BigNumberish): this;
    add(amount: string): TokenAmount;
    add(tokenAmount: TokenAmount): TokenAmount;
    addWei(amountWei: BigNumberish): this;
    sub(amount: string): TokenAmount;
    sub(tokenAmount: TokenAmount): TokenAmount;
    subWei(amountWei: BigNumberish): this;
    isZero(): boolean;
    eq(tokenAmount: TokenAmount): boolean;
    gt(tokenAmount: TokenAmount): boolean;
    gte(tokenAmount: TokenAmount): boolean;
    lt(tokenAmount: TokenAmount): boolean;
    lte(tokenAmount: TokenAmount): boolean;
    toObject(): TokenAmountObject;
    toValues(): [string, BigNumber];
    clone(): TokenAmount;
}
export type TokenAmountTypes = TokenAmountObject | TokenAmountPair | TokenAmount;
export declare function isTokenAmountObject(v: any): v is TokenAmountObject;
export declare function isTokenAmountPair(v: any): v is TokenAmountPair;
export declare function isTokenAmount(v: any): v is TokenAmount;
export declare function isTokenAmountTypes(v: any): v is TokenAmountTypes;
export declare function isTokenAmountObjects(v: any): v is TokenAmountObject[];
export declare class TokenAmounts {
    tokenAmountMap: Record<string, TokenAmount>;
    constructor(tokenAmounts: TokenAmountTypes[]);
    constructor(...tokenAmounts: TokenAmountTypes[]);
    static from(tokenAmountObjects: TokenAmountObject[]): TokenAmounts;
    get length(): number;
    at(index: number): TokenAmount;
    get(tokenOrAddress: TokenOrAddress): TokenAmount;
    set(token: TokenTypes, amount: string): TokenAmounts;
    set(tokenAmount: TokenAmountTypes): TokenAmounts;
    has(tokenOrAddress: TokenOrAddress): boolean;
    add(token: TokenTypes, amount: string): TokenAmounts;
    add(tokenAmount: TokenAmountTypes): TokenAmounts;
    sub(token: TokenTypes, amount: string): TokenAmounts;
    sub(tokenAmount: TokenAmountTypes): TokenAmounts;
    toArray(): TokenAmount[];
    toObject(): TokenAmountObject[];
    toJSON(): TokenAmountObject[];
    toValues(): [string[], BigNumber[]];
    compact(): TokenAmounts;
    isEmpty(): boolean;
    get native(): TokenAmount | undefined;
    get erc20(): TokenAmounts;
    get tokens(): Token[];
    forEach(callbackfn: (value: TokenAmount, index: number, array: TokenAmounts) => void): void;
    map<U>(callbackfn: (value: TokenAmount, index: number, array: TokenAmounts) => U): U[];
    merge(sources: TokenAmounts | TokenAmounts[]): TokenAmounts;
}
export declare function isTokenAmounts(v: any): v is TokenAmounts;
